#!/usr/bin/env perl
#
# gitzone by tg
#
# this program is called from a pre-receive & post-receive git hook, if a push
# is made to the master branch changed files are validated with named-checkzone,
# the push is rejected if there's an error in one of the zone files specified in
# the config file, if everything is OK, the zone files are copied to $zone_dir
# and the zone is reloaded with rndc reload $zone $class $view

use warnings;
use strict;
use POSIX qw/strftime/;
use Cwd qw/cwd realpath/;
use File::Basename qw/fileparse/;

our ($zone_dir, $git, $named_checkzone, $rndc, $class, $default_view, $update_record, $user_includes, $max_depth, $zones, $verbosity);
our $user = getpwuid $<;

@ARGV >= 2 or die "Usage: gitzone /path/to/gitzone.conf <command>\n";
my ($config_file, $cmd) = @ARGV;

do $config_file or die "Can't load config: $!\n";

my $lock_file = realpath '.gitzone-lock';
my $list_file = realpath '.gitzone-list';
my (%files, %inc_files, @zones, $date);
delete $ENV{GIT_DIR};

!-e $lock_file or die "Error: lock file exists\n";
open FILE, '>', $lock_file or die $!; close FILE;

sub cleanup { unlink $lock_file }
sub clean_exit { cleanup; exit shift }
$SIG{__DIE__} = \&cleanup;

($_ = $cmd) &&
    /^pre-receive$/ && pre_receive() ||
    /^post-receive$/ && post_receive() ||
    $update_record && /^update-record$/ && update_record($ARGV[2]);
cleanup;

sub git {
  my ($args, $print, $ret) = @_;
  $ret ||=0;
  print "% git $args\n" if $verbosity >= 2;
  $_ = `$git $args 2>&1`;
  $print = 1 if !defined $print && $verbosity >= 1;
  if ($print) {
    #my $cwd = cwd; s/$cwd//g; # print relative paths
    print;
  }
  if ($ret >= 0 && $? >> 8 != $ret) {
    my ($package, $filename, $line) = caller;
    print;
    die "Died at line $line.\n";
  }
  return $_;
}

# Load BIND config files specified in the $zones config variable.
# First load the -default key, then the $user key.
sub load_zones_config {
  my $key = shift || '-default';

  # move files not in a dir to a . dir for easier processing
  for my $file (keys %{$zones->{$key}}) {
    next if ref $zones->{$key}->{$file} eq 'HASH';
    $zones->{$key}->{'.'}->{$file} = $zones->{$key}->{$file};
    delete $zones->{$key}->{$file};
  }

  for my $dir (keys %{$zones->{$key}}) {
    my $d = $zones->{$key}->{$dir};
    for my $file (keys %$d) {
      $d->{$file} = $default_view if $d->{$file} eq 1;
      $d->{$file} = [$d->{$file}] if ref $d->{$file} ne 'ARRAY';
      next unless $file =~ m,^/,;
      if (-f $file) {
        open FILE, '<', $file or die $!;
        while (<FILE>) {
          if (/^\s*zone\s+"([^"]+)"/) {
            $zones->{$user}->{$dir}->{$1} = $d->{$file};
          }
        }
        close FILE;
      }
      delete $d->{$file} if $key ne '-default';
    }
  }

  load_zones_config($user) if $key eq '-default';
}

sub process_files {
  $files{$_} = 0 for (@_);
  $files{$_} += process_file($_) for keys %files;
  find_inc_by($_) for keys %inc_files;
  check_zones();
}

sub process_file {
  my $file = shift;
  my (@newfile, $changed, @inc_by);
  print ">> process_file($file)\n" if $verbosity >= 3;

  return 0 if $files{$file}; # already processed
  return -1 unless -f $file; # deleted

  open FILE, '<', $file or die $!;
  my $n = 0;
  while (<FILE>) {
    $n++;
    my $line = $_;
    if (/^(.*)(\b\d+\b)(.*?;AUTO_INCREMENT\b.*)$/) {
      # increment serial where marked with ;AUTO_INCREMENT
      # if length of serial is 10 and starts with 20 treat it as a date
      my ($a,$s,$z) = ($1,int $2,$3);
      $date ||= strftime '%Y%m%d', localtime;
      $s = ($s =~ /^$date/ || $s < 2000000000 || $s >= 2100000000) ? $s + 1 : $date.'00';
      $line = "$a$s$z\n";
      $changed = 1;
    } elsif (/^(\W*\$INCLUDE\W+)(\S+)(.*)$/) {
      my ($a,$inc_file,$z) = ($1,$2,$3);
      if ($user_includes) {
        # check $INCLUDE lines for files outside the user dir
        unless ($inc_file =~ m,^$user/, && $inc_file !~ /\.\./) {
          close FILE;
          die "Error in $file:$n: invalid included file name, it should start with: $user/\n";
        }
      }
    } else {
      if ($n == 1 && /^;INCLUDED_BY\s+(.*)$/) {
        # add files listed after ;INCLUDED_BY to %inc_files
        @inc_by = split /\s+/, $1;
        for (@inc_by) {
          $inc_files{$_} = 0 unless exists $files{$_};
        }
      }
    }
    push @newfile, $line;
  }
  close FILE;

  if ($changed) {
    open FILE, '>', $file or die $!;
    print FILE for @newfile;
    close FILE;

    git "commit -m 'auto increment: $file' '$file'", 1;
  }

  return 1;
}

sub find_inc_by {
  my $file = shift;
  my $depth = shift || 1; # recursion depth
  my @inc_by;
  print ">> find_inc_by($file)\n" if $verbosity >= 3;

  return 0 if $files{$file}; # already processed
  return -1 unless -f $file; # deleted
  $files{$_}++;

  open FILE, '<', $file or die $!;
  if (<FILE> =~ /^;INCLUDED_BY\s+(.*)$/) {
    # add files listed after ;INCLUDED_BY to %files
    @inc_by = split /\s+/, $1;
    for (@inc_by) {
      $files{$_} = 0 unless exists $files{$_};
    }
  }
  close FILE;

  if ($depth++ < $max_depth) {
    find_inc_by($_, $depth) for @inc_by;
  } else {
    print "Warning: ;INCLUDED_BY is followed only up to $max_depth levels,\n".
          "  the following files are not reloaded: @inc_by\n";
  }
}

sub check_zones {
  for my $file (keys %files) {
    # skip files with errors and those that are not in the config
    my ($zone, $dir) = fileparse $file;
    $dir = substr $dir, 0, -1;
    next unless $files{$file} > 0 && exists $zones->{$user}->{$dir}->{$zone};

    if ($user_includes) {
      print `$named_checkzone -kn -w .. '$zone' '$user/$file'`;
    } else {
      print `$named_checkzone -kn '$zone' '$file'`;
    }
    clean_exit 1 if $?; # error, reject push
    push @zones, $file;
  }
}

sub install_zones {
  print "Reloading changed zones: @zones\n";

  my $cwd = cwd;
  # move master to new
  git 'checkout -f master';
  git 'reset --hard new';

  chdir "$zone_dir/$user" or die $!;
  git "clone $cwd ." unless -d '.git';
  git 'fetch';
  git 'reset --hard remotes/origin/master';

  for my $file (@zones) {
    my ($zone, $dir) = fileparse $file;
    $dir = substr $dir, 0, -1;
    my $view = $zones->{$user}->{$dir}->{$zone};
    print "$_/$zone: ", `$rndc reload '$zone' $class $_` for @$view;
  }

  unlink $list_file;
}

sub pre_receive {
  my ($old, $new, $ref);
  chdir '..';

  while (<STDIN>) { # <old-value> SP <new-value> SP <ref-name> LF
    print if $verbosity >= 1;
    next unless m,(\w+) (\w+) ([\w/]+),;
    next if $3 ne 'refs/heads/master'; # only process master branch
    die "Denied branch 'new', choose another name\n" if $3 eq 'refs/head/new';
    ($old, $new, $ref) = ($1, $2, $3);
  }

  # nothing for master branch, exit
  clean_exit 0 unless $ref;

  # check what changed
  git "checkout -qf $new";
  if ($old =~ /^0+$/) {
    $_ = git "whatchanged $new";
  } else {
    $_ = git "diff --raw $old..$new";
  }
  # parse diff output, add only valid zone names to %files for parsing
  $files{$1} = 0 while m,^:(?:[\w.]+\s+){5}([a-z0-9./-]+)$,gm;

  load_zones_config;
  process_files;

  if (@zones) {
    print "Zone check passed: @zones\n";
    # save changed zone list for post-receive hook
    open FILE, '>>', $list_file or die $!;
    print FILE join(' ', @zones), "\n";
    close FILE;
  } else {
    print "No zones to reload\n";
  }

  # save new commits in a new branch
  git 'branch -D new';
  git 'checkout -b new';
}

sub post_receive {
  print "\n";
  chdir '..';

  open FILE, '<', $list_file or die $!;
  push @zones, split /[\s\n\r]+/ while <FILE>;
  close FILE;

  load_zones_config;
  install_zones;
  print "Done. Don't forget to pull if you use auto increment.\n";
}

sub update_record {
  my ($c, $file, @record) = split /\s+/, shift;
  my ($ip) = $ENV{SSH_CLIENT} =~ /^([\d.]+|[a-f\d:]+)\s/i or die "Invalid IP address\n";
  my $re = qr/^\s*/i;
  $re = qr/$re$_\s+/i for (@record);
  my $matched = 0;
  my $changed = 0;
  my @newfile;

  chdir $user;
  git 'checkout -f master';

  open FILE, '<', $file or die "$file: $!";
  while (<FILE>) {
    my $line = $_;
    if (!$matched && s/($re)([\d.]+|[a-f\d:]+)/$1$ip/i) {
      print "Matched record:\n$line";
      $matched = 1;
      if ($line ne "$1$ip\n") {
        $changed = 1;
        $line = "$1$ip\n";
        print "Updating it with:\n$line";
      } else {
        print "Not updating: already up-to-date\n";
        close FILE;
        clean_exit 0;
      }
    }
    push @newfile, $line;
  }
  close FILE;
  die "No matching record in $file: @record\n" unless $matched;

  open FILE, '>', $file or die $!;
  print FILE for @newfile;
  close FILE;

  git "commit -m 'update-record: $file' '$file'", 1;

  process_files $file;

  # save new commits in a new branch
  git 'branch -D new';
  git 'checkout -b new';

  install_zones if @zones;
}
